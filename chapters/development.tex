\chapter{Desarrollo}
\label{desarrollo}

En este capítulo se detalla el proceso de recolección de las mamografías y se
presenta el método de preprocesamiento propuesto.

\section{Etapa de recolección}

Las mastografías fueron recolectadas en el Hospital de Alta Especialidad Juan
Graham Casasús. Los casos originalmente son almacenadas en discos compactos y
organizados con un archivo DICOMDIR. 

\begin{table}[h]
  \caption[Etiquetas DICOM]{Etiquetas DICOM que permanecen en la imagen} 
  \label{table:dicomtags}
\begin{center}
{\scriptsize
    \begin{tabular}{c|c}
    \hline

    {\bf Etiquetas} & 
    {\bf Descripción} \\
    \hline
        (7fe0, 0010) & Datos de pixel\\
        (0028, 0103) & Representación de píxeles \\
        (0028, 0010) & Filas \\
        (0028, 0011) & Columnas \\
        (0028, 0100) & Bits alojados \\
        (0028, 0101) & Bits almacenados \\
    \hline
    \end{tabular}
}
\end{center}
\end{table}

Para extraer las imágenes y organizarlas, se utilizó un \textit{script}
programado con el lenguaje de programación \texttt{Python} y la librería
\texttt{PyDICOM}. Se removieron las etiquetas que almacenan los datos privados de los pacientes y los etiquetas
que permanecen en las imágenes se pueden ver en la Tabla \ref{table:dicomtags}.

\section{Método}

Cada mamograma recolectado fue procesado con un método híbrido de cinco etapas.
En la Figura \ref{fig:flowchart} se presenta un diagrama de flujo con las
etapas del método híbrido.

\shorthandoff{>} % hack to combine tikZ and Spanish
    \input{flowchart.tex}
\shorthandon{>} 

\subsection{Reducción del área de trabajo}

La primera etapa del método consiste en eliminar la región oscura que cubre
gran parte de la imagen para acelerar el tiempo de ejecución de los
procedimientos posteriores. El enfoque es similar al expuesto por Dehghani y
Holguín \cite{dehghani2011method, holguinpre}.

% thresholding
Aplicamos un método de tres fases para lograr la reducción: umbralización,
eliminación de objetos y corte automático. En la Figura \ref{reduction} se
muestra cada una de estas fases. 

La primera fase es la \textit{umbralización}, cuyo propósito es separar el
objeto de interés del fondo. Para lograr este cometido, inicialmente la imagen
es convertida de simple precisión a doble precisión, lo que nos permite obtener
mejores resultados en el proceso de binarización. Después, se calcula el valor
\textit{umbral} de la imagen con la función \texttt{graytresh} de Matlab, esta
función implementa el método de Otsu \cite{otsumethod}. El valor umbral que se
obtiene como resultado es usado para clasificar los pixeles como 0 ó 1. El
tercer paso es la binarización, que es ejecutada utilizando una función la
función \texttt{im2bw} de Matlab. El resultado se muestra en la Figura
\ref{red:b}.

\begin{figure}[h]
    \centering

    \subfloat[\label{red:a}]{\includegraphics[height=35mm]{images/dpi150.jpg}}
    \subfloat[\label{red:b}]{\includegraphics[height=35mm]{images/dpi125.jpg}}
    \subfloat[\label{red:c}]{\includegraphics[height=35mm]{images/dpi25.jpg}}
    \subfloat[\label{red:d}]{\includegraphics[height=35mm]{images/dpi50.jpg}}

  \caption[Reducción del área de trabajo]
  {Reducción del área de trabajo. En esta}
  \label{reduction}
\end{figure}

La segunda fase es \textit{eliminación de objetos} que consiste en remover
todos los objetos de la imagen a excepción del área de interés. Por ejemplo, en
la Figura \ref{red:b} podemos ver una etiqueta en la esquina superior derecha
que fue removida en la Figura \ref{red:c}. Lo que realmente hacemos es remover
todos los objetos con menos de 10'000 píxeles, ya que consideramos que un seno
jamás será menor de 10'000 píxeles. Este procedimiento es ejecutado utilizando
la función Matlab llamada \texttt{bwareaopen}.

Finalmente, la fase de corte automático se divide en dos pasos. El primero es
determinar la localización del borde de la imagen, lo que es logrado con la
función de Matlab llamada \texttt{bwboundaries}. Esta función encuentra los
bordes de un objeto utilizando el algoritmo Moore-Neighbor modificado por el
criterio de paro de Jacob \cite{gonzalez2009digital}. Los bordes son utilizados
para determinar los puntos extremos de cada seno (ver \ref{red:d}). El segundo
paso es hacer el corte usando estos puntos extremos (ver \ref{red:d}). % red:e

\subsection{Conversión de bits}

Como ya se mencionó antes, las imágenes están en el formato DICOM. El formato
DICOM representa las imágenes con 4'096 niveles de grises, esto es 12 bits de
profundidad. Matlab representa estas imágenes utilizando 16 bits de
profundidad, o sea, 65'536 niveles de grises \cite{mustra2008efficient}. Cuando
una imagen de 12 bits es visualizada con un visor de 16 bits, esta luce oscura,
ver Figura X. Para mostrar la imagen correctamente esta necesita ser convertida
a una imagen de 16 bits. Se aplicó la Ecuación \ref{eq:bitconv} a cada pixel en
la imagen para realizar la conversión.

\begin{equation}
\label{eq:bitconv}
    \begin{split}
            \ell &= \frac{2^{n}}{2^{m}} \\
            c_{x,y} &= i_{x, y} \times \ell,
    \end{split}
\end{equation}

\noindent donde $\ell$ es un valor escalar, $n$ es el número de bits de la imagen
objetivo, $m$ es el número de bits en la imagen original. La vieja matriz es
representada con $i$ y la nueva con $c$. El par $x$ y $y$ representan la
posición de los píxeles en cada matriz.

\subsection{Eliminación de ruido}
Se elimina el ruido.

\subsection{Mejora del contraste}
Se mejora el contraste.

\subsection{Compresión} \label{compression}

%This is the final phase in our method. It deals with image compression. A
%compressed image takes less time for transmission, processing, and less storage
%capacity. We applied a technique introduced by AbuBaker
%\cite{abubaker2006mammogram}  abubaker2007efficient}. It aims at compressing an
%image with minimal loss of quality. 
%
%%We introduced small changes to the original method, making the bit conversion
%%with the algorithm proposed for the enhancement and applying after that a
%%normalization step.
%
%The applied method consists of three steps: image shrinking procedure, pixel
%depth conversion, and image enhancement. Description of each step follows. 
%
%\subsubsection{Image shrinking procedure.} 
%Here, we will find the maximum shrinking level of the image. It takes three
%substeps:
%
%\begin{enumerate}[a)]
%    \item Obtain the image histogram (see Fig. \ref{comp:a} and \ref{comp:b}). %% DESCRIBIR QUE SE HIZO AQUI
%    \item Modify the histogram by deleting the unused gray levels (gaps) in the
%    histogram. The result will be a right-skewed histogram, as shown in Fig.
%    \ref{comp:c}.  
%    \item Generate an image based on the new histogram. The new image will be
%    quite dark due to the gray levels being located in the dark side section, Fig. \ref{comp:d}.
%\end{enumerate}
%
%\begin{figure}[h]
%  \begin{center}
%    \hspace{\fill}
%    \subfloat[\label{comp:a}]{\includegraphics[height=30mm]{images/original-mammogram-16bits}}
%    \hfill
%    \subfloat[\label{comp:b}]{\includegraphics[height=30mm]{images/original-image-histogram}}
%    \hfill
%    \subfloat[\label{comp:c}]{\includegraphics[height=30mm]{images/shrunk-histogram}}
%    \hfill
%    \subfloat[\label{comp:d}]{\includegraphics[height=30mm]{images/dark-mammogram}}
%    \hspace{\fill}
%  \end{center}
%
%  \caption{Shrinking procedure. \subref{comp:a} original mammogram,
%  \subref{comp:b} histogram of \subref{comp:a}, \subref{comp:c} histogram shown
%  in \subref{comp:b} after being shrunk, and \subref{comp:d} is the dark image
%  generated from the shrunk histogram.} 
%  
%  \label{img:shrinking-one} \end{figure}
%
%%\begin{verbatim}
%
%%\end{verbatim}
%
%\subsubsection{Pixel depth conversion.} 
%In this step the goal is to reduce the size of the image. Three substeps are
%involved:
%
%\begin{enumerate}[a)] %% NECESITAMOS AGREGAR DESCRIPCION DE CADA UNO DE ESTOS SUBSTEPS
%    \item Extract the histogram of the shrunk image.
%    \item Find the maximum shrinking level for the image.
%    \item Reduce image from 16 to 8 bits. 
%\end{enumerate}
%
%The shape of the original histogram shown in Fig. \ref{comp:b} is quite similar
%to the histogram of the resultant image shown in Fig. \ref{comp:g}. Peaks look
%the same, which indicates that the concentration of gray levels remains
%unchanged.
%
%\begin{figure}[h]
%  \begin{center}
%    \hspace{\fill}
%    \subfloat[\label{comp:e}]{\includegraphics[height=30mm]{images/dark-mammogram-histogram}}
%    \hfill
%    \subfloat[\label{comp:f}]{\includegraphics[height=30mm]{images/compressed-mammogram-8bits}}
%    \hfill
%    \subfloat[\label{comp:g}]{\includegraphics[height=30mm]{images/compressed-mammogram-histogram}}
%    \hspace{\fill}
%  \end{center}
%
%  \caption{(a) shows histogram generated from the dark mammogram, (b) is the 8 
%  bits mammogram, and (c) is the histogram of 8-bit image, which is similar to 
%  the original mammogram.} 
%  
%  \label{img:shrinking-two}
%\end{figure}
%
%\subsubsection{Enhancing pixel depth conversion.}
%This step aims at improving brightness of the image obtained from pixel depth
%conversion.  Afterwards, image conversion from 16 to 8 bits using an efficient
%coefficient takes place.  Medical information carried by the image should be
%maintained. %% AGREGAR REFERENCIA A UNA FIG., SI LA HAY

% change the words in this paragrap

%This final step is useful like a normalization process. Below is presented the 
%Matlab code used:

\definecolor{bg}{rgb}{0.9,0.9,0.9}
\begin{minted}[linenos=true, 
               %fontfamily=fi4, 
               fontseries=ubx,
               bgcolor=bg, frame=lines]{matlab}
% Get the size of the image
% Based on Abubaker code
[height width] = size(image);
imageCopy = repmat(uint8(0), height, width);
divider = 0.0;
maxLevel = double(usedGrayLevels);

while 1
    divider = divider + 0.01;
    if maxLevel/divider <= 255
        break;
    end
end
fprintf('text');
for h=1:1:height
    for w=1:1:width
       imageCopy(h, w) = image(h, w)/divider;
    end
end
\end{minted}

%Recordar escribir que en las primeras pruebas sólo se mejoró  la visualización
%del tejido graso y no del tejido mamario.


